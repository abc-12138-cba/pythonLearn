"""
_可变与不可变_操作_常用方法_数学运算_遍历
  集合：无序、元素唯一的容器类型。 --> 集合是可以去重的数据容器，当只关心元素是否存在，而不在乎顺序的时，首选集合
    无序：指从集合中取出元素的顺序，与定义集合时存入的顺序不一定一致
    元素必须是不可变类型（如：数字、字符串、元组）。

  分为两种： 
    1. 可变集合（set）：内部的元素无序（不保证顺序）、不能通过下标访问元素、会自动去除重复元素。
    2. 不可变集合（forzenset）：特点和可变集合一样，唯一的区别就是：其中的元素不可修改。

  集合中不能嵌套【可变集合】，但可以嵌套【不可变集合】

  操作：
    1. 增加
      集合.add(元素)：向集合中添加元素
      集合.update(元素)： 向集合中批量添加元素（接收可迭代对象），无返回值
    2. 删除
      集合.remove(元素)，从集合中移除指定元素（若元素不存在，会报错）
      集合.discard(元素)，从集合中移除指定元素（若元素不存在，不会报错）
      集合.pop()，从集合中移除一个任意元素，返回值：移除的那个元素
      集合.clear()，清空集合，无返回值
    3. 修改
      集合没有下标，一般通过remove+add的组合，来达到“修改”的效果。
    4. 查询
      集合没有下标，不具备按位置访问的能力，但可以使用【成员运算符】来判断

  常用方法：
    1. 集合A.difference(集合B)：返回一个新集合，包含在集合A中但不在集合B中的元素
    2. 集合A.difference_update(集合B)：从集合A中移除所有在集合B中的元素，无返回值
    3. 集合A.union(集合B)：返回一个新集合，包含集合A和集合B中的所有元素（自动去重）
    4. 集合A.issubset(集合B)：判断集合A是否是集合B的子集，返回值：True/False
    5. 集合A.issuperset(集合B)：判断集合A是否是集合B的超集，返回值：True/False
    6. 集合A.isdisjoint(集合B)：判断集合A和集合B是否没有交集，返回值为布尔值，如果没有交集，返回True

  集合的数学运算：
    并集：s1 | s2；交集：s1 & s2；差集：s1 - s2；对称差集：s1 ^ s2

  集合的遍历
    集合不支持下标，不支持while循环，for循环可以
"""

# 定义有内容的【可变集合】
s1 = {10, 31, 20, 20, 30}
print(type(s1), s1) # <class 'set'> {10, 20, 30, 31}

# 定义空集合（可变集合）
#   不能直接写{}来定义空集合，因为直接写{}定义的是：空字典。
s1 = set()
print(type(s1), s1)  # <class 'set'> set()


# frozenset 接收的参数，可以是任意可迭代对象，但最终返回的一定是【不可变集合】
s1 = frozenset([10, 20, 30, 40, 50])
print(type(s1), s1) # <class 'frozenset'> frozenset({40, 10, 50, 20, 30})

# 定义空集合（不可变集合）
s3 = frozenset()
print(type(s3), s3) # <class 'frozenset'> frozenset()


# add方法：向集合中添加元素
s1 = {10, 20, 30, 40, 50}
s1.add(60)
print(s1)

s1 = {10, 20, 30, 40, 50}
s1.update([60, 70])
print(s1)


s1 = {10, 20, 30, 40, 50}
# s1[0] # 此行报错，因为集合不能通过下标访问元素

# 先提前感受一下成员运算符
result = 20 not in s1
print(result)


s1 = {10, 20, 30, 40, 50}
s2 = {30, 40, 50, 60, 70}
s1.difference_update(s2)
print(s1) # {20, 10}
print(s2)

a = 2
s1 = {10, 31, 20, 20, 30, a}
print(s1)